<html>
  <head>
    <title> PyLing </title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
  <h1><div class='semiopacity'><a name="type">Типы данных</a></div></h1>
  <p>Данные в языке Python представлены в форме объектов. Объекты – это области памяти со значениями и ассоциированными с ними наборами операций. Типы объектов могут быть либо встроенными, либо описанными с помощью классов. Однако создание собственных структур данных чаще всего не требуется, так как Python имеет мощную коллекцию собственных. Кроме того, их использование предпочтительнее, так как скорость работы с ними намного выше. Итак, используемые нами типы данных:</p>
	<ul>
		<li><a href="#num" target="_self">Числа</a></li>
		<ul>
		<li><a href="#log" target="_self">Логические</a></li>
		</ul>
		<li><a href="#str" target="_self">Строки</a></li>
		<li><a href="#list" target="_self">Списки</a></li>
		<li><a href="#tup" target="_self">Кортежи</a></li>
		<li><a href="#dic" target="_self">Словари</a></li>
		<li><a href="#set" target="_self">Множества</a></li>
		<li><a href="#file" target="_self">Файлы</a></li>
	</ul></p>


<div class='semiopacity'><h2><a name="num">Числа</a></h2></div>
<p>Если вы уже занимались программированием, группа числовых типов данных скорее всего покажется вам знакомой. Мы будем использовать целые числа (числа без дробной части), вещественные числа (грубо говоря, числа с десятичной точкой) и числа с фиксированной точностью. Естественно, числа поддерживают базовые математические операции. </p>
<table>
<tr><td>x + y или x += y</td><td><a href="img/add.jpg" target="_blank">Сложение</a></td></tr>
<tr><td>x - y или x -= y</td><td>Вычитание</td></tr>
<tr><td>x * y</td><td>Умножение</td></tr>
<tr><td>x / y</td><td>Деление</td></tr>
<tr><td>x // y</td><td>Получение целой части от деления</td></tr>
<tr><td>x % y</td><td>Остаток от деления</td></tr>
<tr><td>-x</td><td>Смена знака числа</td></tr>
<tr><td>abs(x)</td><td>Модуль числа</td></tr>
<tr><td>divmod(x, y)</td><td>Пара (x // y, x % y)</td></tr>
<tr><td>x ** y или pow(x, y)</td><td>Возведение в степень<img src="img/pythonlogolol.png" height="20" align="right" hspace="10"></td></tr>
</table>
 <div class='codopacity'><p class="code"><pre>
>>> 123 + 222
345
>>> 1.5 * 4
6.0</pre></p></div>
<p>Можете заметить, что в результате проведения второй операции, то есть умножения вещественного числа на целое, компилятор вернул вещественное число. Это произошло, потому что из двух типов данных, над которыми производятся операции, всегда выбирается супертип (тот, который имеет большую выразительную мощность).</p>
<p>Будьте внимательны, если вам нужно получить результат деления двух целых чисел! Для того, чтобы увидеть дробную часть, необходимо, чтобы хотя бы одно из них было вещественным.</p>
<div class='codopacity'><p class="code"><pre>
>>> 4/3
1
>>> 4/3.0
1.3333333333333333 </pre></p></div>
<p>Хорошая новость: в Python3 такого "наследования типов" больше нет, результатом деления двух целых чисел будет вещественное.</p>
<div class='codopacity'><p class="code"><pre>
>>> 9/7
1.2857142857142858 </pre></p></div>
<p>Ок, что если мы не хотим видеть эту кучу цифр, а нам нужно число с тремя знаками после запятой? Для этого есть форматированный вывод...</p>
<div class='codopacity'><p class="code"><pre>
>>> '{0:.3f}'.format(9/7)
'1.286' </pre></p></div>
<p>А если нам наоборот нужно увидеть больше цифр? Для этого и существуют числа с фиксированной точностью.</p>
<div class='codopacity'><p class="code"><pre>
>>> >>> import decimal
>>> d= decimal.Decimal(9/7)
>>> d
Decimal('1.2857142857142858094476878250134177505970001220703125')
</pre></p></div>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>


<h2><div class='semiopacity'><a name="log">Логические (Булевские)</a></div></h2>
<p>В Python существуют объекты True и False, которые по сути являются обычными целыми числами 1 и 0 с некоторыми особенностями отображения на экране</p>
<div class='codopacity'><p class="code"><pre>
>>> 1 > 2, 1 < 2 # Логические значения
(False, True)
>>> 3 + True
4
</pre></p></div>
<p>Кроме того, существует None, которое выражает отсутствие значения. Пример использования:</p>
<div class='codopacity'><p class="code"><pre>
>>> def test(x=None):
...   if x is None:
...     print('no x here')
...   else:
...     print(x)
... 
>>> test()
no x here
>>> test('x!')
x!
</pre></p></div>
<p>Объект None также используется при рекурсии: после того, как уровень возвращает значение None (выполнены все требуемые операции), программа возвращается к предыдущему уровню. <a href = "illustration.html" target="_blanc"><img src="img/illustration.png" height='50' align="top"></a> </p>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>


<h2><div class='semiopacity'><a name="str">Строки</a></div></h2>
<p>Cтроки могут задаваться как апострофами, так и кавычками. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов.</p>
<div class='codopacity'><p class="code"><pre>
>>> S = 'spam"s' 
>>> S = "spam's"</pre></p></div>
<p>Строки являются последовательностями, то есть одна строка представляет собой последовательность односимвольных строк, к которым можно обращаться при помощи индексов. Обратите внимание, что в языке Python индексы реализованы в виде смещений от начала и потому индексация начинается с 0: первый элемент имеет индекс 0, второй – 1 и так далее. Также возможна индексация в обратном порядке, где последний элемент имеет индекс -1, предпоследний – -2.</p>
<div class='codopacity'><p class="code"><pre>
>>> S = ‘Spam’
>>> len(S) # Длина
4
>>> S[0] # Первый элемент в S, счет начинается с позиции 0
‘S’
>>> S[1] # Второй элемент слева
‘p’
>>> S[-1] # Последний элемент в конце S
‘m’
>>> S[-2] # Второй элемент с конца
‘a’</pre></p></div>
<p>Помимо извлечения конкретного элемента посредством индексирования уществует возможность получения среза (slicing), которая обеспечивает возможность извлечения за одну операцию целого сегмента (среза)</p>
<div class='codopacity'><p class="code"><pre>
>>> S # Строка из 4 символов
‘Spam’
>>> S[1:3] # Срез строки S начиная со смещения 1 и до 2 (не 3)
‘pa’’ 
>>> S[1:] # Все, кроме первого элемента (1:len(S))
‘pam’
>>> S # Сама строка S без изменений
‘Spam’
>>> S[0:3] # Все, кроме последнего элемента
‘Spa’
>>> S[:3] # То же, что и S[0:3]
‘Spa’
>>> S[:-1] # Еще раз все, кроме последнего элемента, но проще (0:-1)
‘Spa’
>>> S[:] # Все содержимое S, как обычная копия (0:len(S))
‘Spam’</pre></p></div>
<p>Будучи последовательностями, строки поддерживают операцию конкатенации, которая записывается в виде знака плюс (объединение двух строк
в одну строку), и операцию повторения (новая строка создается за счет много-
кратного повторения другой строки)</p>
<div class='codopacity'><p class="code"><pre>
>>> S
‘Spam’
>>> S + ‘xyz’ # Конкатенация
‘Spamxyz’
>>> S # S остается без изменений
‘Spam’
>>> S * 8 # Повторение
‘SpamSpamSpamSpamSpamSpamSpamSpam’</pre></p></div>
<p>Строки являются неизменяемыми, поэтому в предыдущих примерах ни одна из использованных операций не изменила оригинальную строку. Вы не сможете изменить строку присвоением значения одной из ее позиций, но вы всегда можете создать новую строку и присвоить ей то же самое имя.</p>
<div class='codopacity'><p class="code"><pre>
>>> S
‘Spam’
>>> S[0] = ‘z’ # Неизменяемые объекты нельзя изменить
...текст сообщения об ошибке опущен...
TypeError: ‘str’ object does not support item assignment
>>> S = ‘z’ + S[1:] # Но с помощью выражений мы можем создавать новые объекты
>>> S
‘zpam’</pre></p></div>
<p class="bold">Базовые операции над строками:</p>
<div class='codopacity'><p class="code"><pre>
>>> S.find(‘pa’) # Поиск смещения подстроки
1
>>> S.replace(‘pa’, ‘XYZ’) # Замена одной подстроки другой
‘SXYZm’
>>> S.upper() # Преобразование символов в верхний и в нижний регистр
‘SPAM’
>>> S.isalpha() # Проверка содержимого: isalpha, isdigit и так далее
True
>>> line = ‘aaa,bbb,ccccc,dd’
>>> line.split(‘,’) # Разбивает строку по разделителю и создает список строк
[‘aaa’, ‘bbb’, ‘ccccc’, ‘dd’]
>>> line = ‘aaa,bbb,ccccc,dd\n’
>>> line = line.rstrip() # Удаляет завершающие пробельные символы
>>> line
‘aaa,bbb,ccccc,dd’</pre></p></div>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>


<h2><div class='semiopacity'><a name="list">Списки</a></div></h2>
<p>Списки – это упорядоченные по местоположению коллекции
объектов произвольных типов, размер которых не ограничен. Кроме того, в от-
личие от строк, списки являются изменяемыми – они могут модифицироваться как с помощью операций присваивания по смещениям, так и с помощью
разнообразных методов работы со списками.</p>
<p>Поскольку списки являются последовательностями, они поддерживают все
операции над последовательностями, которые были приведены в разделе строк.</p>
<div class='codopacity'><p class="code"><pre>
>>> L = [123, ‘spam’, 1.23] # Список из трех объектов разных типов
>>> len(L) # Число элементов в списке
3
>>> L[0] # Доступ к элементу списка по его индексу
123
>>> L[:-1] # Операция получения среза возвращает новый список
[123, ‘spam’]
>>> L + [4, 5, 6] # Операция конкатенации также возвращает новый список
[123, ‘spam’, 1.23, 4, 5, 6]
>>> L # Наши действия не привели к изменению оригинального списка
[123, ‘spam’, 1.23]</pre></p></div>
<p>Списки в языке Python являются аналогом массивов в других языках программирования, но они обладают более широкими возможностями. Рассмотрим основные операции, характерные для списков.</p>
<div class='codopacity'><p class="code"><pre>
>>> L.append(‘NI’) # Увеличение: в конец списка добавляется новый объект
>>> L
[123, ‘spam’, 1.23, ‘NI’]
>>> L.pop(2) # Уменьшение: удаляется элемент из середины списка
1.23
>>> L # Инструкция “del L[2]” также удалит элемент списка
[123, ‘spam’, ‘NI’]
>>> L.index('NI') #определяет индекс первого элемента с указанным значением 
2
>>> L.count('NI') #считает количество элементов
1
>>> M = [‘bb’, ‘aa’, ‘cc’]
>>> M.sort()
>>> M
[‘aa’, ‘bb’, ‘cc’]
>>> M.reverse()
>>> M
[‘cc’, ‘bb’, ‘aa’]
</pre></p></div>
<p>Рассмотрим различие методов append() и extend():</p>
<div class='codopacity'><p class="code"><pre>
>>> L = [1, 2]
>>> D = [3, 4]
>>> L.append(D)
>>> L
[1, 2, [3, 4]]
>>> L = [1, 2]
>>> D = [3, 4]
>>> L.extend(D)
>>> L
[1, 2, 3, 4]
</pre></p></div>
<p>Одна из замечательных особенностей базовых типов языка Python состоит
в том, что они поддерживают возможность создания вложенных конструкций. Одно из очевидных применений этой особенности – представление матриц, или
«многомерных массивов» в языке Python. Делается это с помощью списка, содержащего вложенные списки:</p>
<div class='codopacity'><p class="code"><pre>
>>> M = [[1, 2, 3], # Матрица 3 x 3 в виде вложенных списков
		[4, 5, 6], # Выражение в квадратных скобках может
		[7, 8, 9]] # занимать несколько строк
>>> M
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> M[1] # Получить строку 2
[4, 5, 6]
>>> M[1][2] # Получить строку 2, а затем элемент 3 в этой строке
6 </pre></p></div>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>


<h2><div class='semiopacity'><a name="tup">Кортежи</a></div></h2>
<p>Кортеж — это список, который невозможно изменить. Кортежи поддерживают большинство операций, доступных для списков.</p>
<div class='codopacity'><p class="code"><pre>
>>> T = (1, 2, 3, 4) # Кортеж из 4 элементов
>>> len(T) # Длина
4
>> T + (5, 6) # Конкатенация
(1, 2, 3, 4, 5, 6)
>>> T[0] # Извлечение элемента, среза и так далее
1
</pre></p></div>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>


<h2><div class='semiopacity'><a name="dic">Словари</a></div></h2>
<p>Словари являются неупорядоченными коллекциями объектов, доступ к элементам которых предоставляется с помощью ключа (такие коллекции называются отображениями). Словарь состоит из пар ключ:значение. Словари удобно использовать всегда, когда возникает необходимость связать значения с ключами, например чтобы описать свойства чего-либо. Рассмотрим базовые операции:</p>
<div class='codopacity'><p class="code"><pre>
>>> D = {‘food’: ‘Spam’, ‘quantity’: 4, ‘color’: ‘pink’}
>>> D[‘food’] # Получить значение, связанное с ключом ‘food’
‘Spam’
>>> D[‘quantity’] += 1 # Прибавить 1 к значению ключа ‘quantity’
>>> D
{‘food’: ‘Spam’, ‘color’: ‘pink’, ‘quantity’: 5}
>>> D['music'] = 'rock' #добавляем пару в словарь
>>> {‘color’: ‘pink’, ‘food’: ‘Spam’, 'music': 'rock', ‘quantity’: 5}
>>> D.keys() #получаем список ключей
dict_keys(['color', 'quantity', 'music', 'food'])
>>> D.values() #получаем список значений
dict_values(['pink', 5, 'rock', 'Spam'])
</pre></p></div>
<p>Словари, так же как и списки, могут иметь несколько уровней вложенности.</p>
<div class='codopacity'><p class="code"><pre>
>>> rec = {‘name’: {‘first’: ‘Bob’, ‘last’: ‘Smith’},
‘job’: [‘dev’, ‘mgr’],
‘age’: 40.5}
>>> rec[‘name’] # ‘Name’ – это вложенный словарь
{‘last’: ‘Smith’, ‘first’: ‘Bob’}
>>> rec[‘name’][‘last’] # Обращение к элементу вложенного словаря
‘Smith’
>>> rec[‘job’] # ‘Job’ – это вложенный список
[‘dev’, ‘mgr’]
>>> rec[‘job’][-1] # Обращение к элементу вложенного списка
‘mgr’
>>> rec[‘job’].append(‘janitor’) # Расширение списка должностей Боба (Bob)
>>> rec
{‘age’: 40.5, ‘job’: [‘dev’, ‘mgr’, ‘janitor’], ‘name’: {‘last’: ‘Smith’,
‘first’: ‘Bob’}}
</pre></p></div>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>


<h2><div class='semiopacity'><a name="set">Множества</a></div></h2>
<p>Множества – это неупорядоченные коллекции уникальных и неизменяемых объектов, которые поддерживают типичные математические операции над множествами.</p>
<div class='codopacity'><p class="code"><pre>
>>> X = set(‘spam’) # В 2.6 и 3.0 можно создавать из последовательностей
>>> Y = {‘h’, ‘a’, ‘m’} # В 3.0 можно определять литералы множеств
>>> X, Y
({‘a’, ‘p’, ‘s’, ‘m’}, {‘a’, ‘h’, ‘m’})
>>> X & Y # Пересечение
{‘a’, ‘m’}
>>> X | Y # Объединение
{‘a’, ‘p’, ‘s’, ‘h’, ‘m’}
>>> X – Y # Разность
{‘p’, ‘s’}
</pre></p></div>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>


<h2><div class='semiopacity'><a name="file">Файлы</a></div></h2>
<p>Объекты-файлы – это основной интерфейс между программным кодом на языке Python и внешними файлами на компьютере.</p>
<div class='codopacity'><p class="code"><pre>
>>> f = open(‘data.txt’, ‘w’) # Создается новый файл для вывода
>>> f.write(‘Hello\n’) # Запись строки байтов в файл
6
>>> f.write(‘world\n’) # В Python 3.0 возвращает количество записанных байтов
6
>>> f.close() # Закрывает файл и выталкивает выходные буферы на диск
>>> f = open(‘data.txt’) # ‘r’ – это режим доступа к файлу по умолчанию
>>> text = f.read() # Файл читается целиком в строку
>>> text
‘Hello\nworld\n’
>>> text1 = f.readlines() # text1 - список, состоящий из строк файла.
>>> text1
['Hello\n', 'world\n']
>>> text2 = f.readline() # считывает 1 строчку из файла
>>> text2
'Hello\n'
>>> text2 = f.readline() #при каждом вызове читает первую из оставшихся строчек
>>> text2
'world\n'
>>> print(text) # Вывод, с попутной интерпретацией служебных символов
Hello
world
>>> text.split() # Содержимое файла всегда является строкой
[‘Hello’, ‘world’]
</pre></p></div>
<div class="right"><a href="#type" target="_self">наверх ↑</a></div>
  </body>
 </html>